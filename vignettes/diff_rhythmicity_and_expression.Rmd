---
title: "Analyzing circadian transcriptome data with LimoRhyde"
author: "Jordan Singer"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Analyzing circadian transcriptome data with LimoRhyde}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = '#>')
```

LimoRhyde is a framework for differential analysis of rhythmic transcriptome data. Here we go through the typical steps of an analysis: identifying rhythmic genes, identifying differentially rhythmic genes, and identifying differentially expressed genes. This example is based on a dataset of gene expression from livers of wild-type and Rev-erb\alpha/\beta knockout mice.

## Gathering Experimental Data

In this first stage, we will be gathering experimental data from the [GSE34018](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE34018) dataset.

### Load Necessary Packages

```{r, message=FALSE}
library(annotate)
library(limorhyde)
library(GEOquery)
library(tidyverse)
library(knitr)
library(limma)
library(rain)
library(foreach)
library(ggplot2)
library(org.Mm.eg.db)
```

We need to define q-value thresholds for rhythmic and differentially rhythmic genes.
```{r}
qvalRhyCutoff = 0.15
qvalDrCutoff = 0.1
```

### Gather dataset from GEOquery

Using getGEO from GEOquery, we download the GSE34018 dataset.
```{r, message=FALSE}
gse = getGEO("GSE34018", GSEMatrix = TRUE)
```

We also gather metadata for the experiment.
```{r, message=FALSE}
sm = as_tibble(pData(phenoData(gse[[1]]))) %>%
  transmute(title = title,
            sample = geo_accession,
            genotype = `genotype/variation:ch1`,
            time = as.numeric(sub("_.*", "", sub(".*_ZT", "", title))),
            cond = factor(genotype, c('wild-type', 'Reverb alpha/beta DKO'), c('wild-type', 'knockout'))) %>%
  arrange(time)

kable(sm[1:5,])
```

We can now apply LimoRhyde to our dataset by appending two new columns to the metadata; `time_cos` and `time_sin`, which are generated by computing the first harmonic of a Fourier decomposition on the `time` column.
```{r}
sm = bind_cols(sm, limorhyde(sm, 'time'))
```

Applying the following optional steps allow us to use the gene symbol names in the subsequent plots.
```{r message=FALSE}
getGeneProbeMappingAnno = function(featureDf, dbName, interName) {
	mappingProbeIntermediate = featureDf[!is.na(featureDf[,interName]) & featureDf[,interName] != '', c('ID', interName)]
	colnames(mappingProbeIntermediate) = c('probeSet', 'geneInter')

	mapTmp1 = eval(parse(text = sprintf('%s.db::%s', substr(dbName, 1, 9), dbName)))
	mapTmp2 = AnnotationDbi::mappedkeys(mapTmp1)
	mapTmp3 = as.list(mapTmp1[mapTmp2])
	geneId = do.call(c, mapTmp3)

	geneInter = do.call(c, mapply(function(inter, len) rep_len(inter, len), names(mapTmp3), sapply(mapTmp3, length),
											SIMPLIFY = FALSE))
	if (dbName == 'org.Hs.egUNIGENE2EG') {
		geneInter = sub('Hs.', '', geneInter, fixed = TRUE)}
	mappingIdInter = data.frame(geneId, geneInter, stringsAsFactors = FALSE)
	return(merge(mappingIdInter, mappingProbeIntermediate, by = 'geneInter', sort = FALSE))}

calcExprsByGene = function(eset, mapping) {
	geneIds = unique(mapping[,'geneId'])
	exprsByGene = matrix(nrow = length(geneIds), ncol = ncol(eset), dimnames = list(geneIds, Biobase::sampleNames(eset)))
	for (geneId in geneIds) {
		exprsTmp = Biobase::exprs(eset)[mapping[mapping[,'geneId'] == geneId, 'probeSet'], , drop = FALSE]
		if (nrow(exprsTmp) == 1) {
			exprsByGene[geneId,] = exprsTmp
		} else {
			exprsByGene[geneId,] = matrixStats::rowMedians(t(exprsTmp), na.rm = TRUE)}}
	return(exprsByGene)}

fixGeoSampleNames = function(sampleNames) {
	sampleNames = paste0(toupper(sampleNames), '_')
	regexResult = regexpr('^GSM[0-9]+[^0-9]', sampleNames)
	sampleNamesNew = mapply(function(sampleName, matchLength) substr(sampleName, 1, matchLength - 1), sampleNames,
									attr(regexResult, 'match.length'))
	return(unname(sampleNamesNew))}
```

```{r message=FALSE}
featureDf = pData(featureData(gse$GSE34018_series_matrix.txt.gz))
idx = sapply(featureDf, is.factor)
featureDf[idx] = lapply(featureDf[idx], as.character)

featureDf[,'RefSeq'] = sapply(featureDf[,'GB_ACC'], function(x) strsplit(x, split = '.', fixed = TRUE)[[1]][1])
mapping = getGeneProbeMappingAnno(featureDf, dbName = 'org.Mm.egREFSEQ2EG', interName = 'RefSeq')
```

Now, we populate the expression set and expression matrix for our dataset.
```{r}
emat = log2(calcExprsByGene(gse$GSE34018_series_matrix.txt.gz, mapping))
```

## Identifying rhythmic genes

We'll be using [RAIN](https://doi.org/doi:10.18129/B9.bioc.rain) to determine rhythmicity.
```{r, message=FALSE}
smGroups = distinct(sm, cond)
rhyRain = foreach(ii = 1:nrow(smGroups), .combine = rbind) %do% {
  smNow = sm %>%
    filter(cond == smGroups[ii,]$cond)
  tt = smNow$time
  ematNow = emat[,smNow$sample]
  
  r = rle(sort(tt))
  deltat = min(diff(unique(tt)))
  
  msrSeq = tibble(tt = seq(min(tt), max(tt), deltat)) %>%
    full_join(tibble(tt = r$values, n = r$lengths), by = 'tt') %>%
    mutate(n = ifelse(is.na(n), 0, n))
  
  result = rain(t(ematNow), deltat = deltat, period = 24, measure.sequence = msrSeq$n)
  result$geneId = rownames(ematNow)
  result = cbind(result, smGroups[ii,])
  return(result)
}
rownames(rhyRain) = NULL

kable(rhyRain[1:5,])
```

After applying RAIN to our dataset, we can use the q-values of rhythmicity to filter the genes, leaving us with only genes whose q-values fall below our predefined threshold.
```{r}
rhyGenes = rhyRain %>%
  group_by(geneId) %>%
  summarize(pVal = min(pVal)) %>%
  group_by() %>%
  mutate(qval = p.adjust(pVal, method = 'BH')) %>%
  filter(qval <= qvalRhyCutoff) %>%
  arrange(qval)
```

## Computing differential rhythmicity and differential expression

We can now use [limma](https://doi.org/doi:10.18129/B9.bioc.limma) to analyze the genes that we determined to be rhythmic.

### Identify rhythmic genes

Calculate differential rhythmicity of rhythmic genes, based on interactions between `cond` and the two `time` components.
```{r, message=FALSE}
design = model.matrix(~ cond * (time_cos + time_sin), data = sm)

fit = lmFit(emat, design)
fit = eBayes(fit, trend=TRUE)
drLimma = topTable(fit, coef = 5:6, number = Inf)

drLimma$geneId = rownames(drLimma)
rownames(drLimma) = NULL
drLimma = semi_join(drLimma, rhyGenes, by = 'geneId')
drLimma$adj.P.Val = p.adjust(drLimma$P.Value, method = 'BH')

kable(drLimma[1:5,])
```

Calculate differential expression of non-differentially rhythmic genes, based on the coefficient for `cond` in a linear model with no interaction terms.
```{r, message=FALSE}
design = model.matrix(~ cond + time_cos + time_sin, data = sm)

fit = lmFit(emat, design)
fit = eBayes(fit, trend = TRUE)
deLimma = topTable(fit, coef = 2, number = Inf)

deLimma$geneId = rownames(deLimma)
rownames(deLimma) = NULL
deLimma = anti_join(deLimma, filter(drLimma, adj.P.Val <= qvalDrCutoff), by = 'geneId')
deLimma$adj.P.Val = p.adjust(deLimma$P.Value, method='BH')

kable(deLimma[1:5,])
```

## Plotting the results

We have many options for plotting. One is to make a volcano plot of differentially expressed genes.
```{r fig.width=6, fig.height=4, message=FALSE}
ggplot(data = deLimma) +
  geom_point(aes(x = logFC, y = -log10(adj.P.Val)), size = 0.2) + 
  coord_fixed(0.2) + 
  labs(x = expression(log[2]*'(fold-change)'), y = expression(-log[10]*'('*q[DE]*')'))
```

We can also plot expression as a function of time and genotype for individual genes. These plots show expression over time of, in order, the most most rhythmic gene, most differentially rhythmic gene, and most differentially expressive gene.
```{r fig.width=6, fig.height=4, message=FALSE}
geneIdsNow = c(rhyGenes$geneId[1], drLimma$geneId[1], deLimma$geneId[1])
geneSymbolsNow = getSYMBOL(geneIdsNow, 'org.Mm.eg.db')

df = as_tibble(t(emat[geneIdsNow,]))
colnames(df) = geneSymbolsNow
df$sample = colnames(emat[geneIdsNow,])

# TODO: the command below can't work, because columns named cond, time, and geneSymbolsNow don't exist
# TODO: look up what the double exclamation points do in the gather function
# TODO: order genes (and revise text) to show rhythmic gene, diff. rhythmic gene, and diff. expressed gene
df = df %>%
  inner_join(sm, by = 'sample') %>%
  select(sample, cond, time, geneSymbolsNow) %>%
  gather(key = 'geneSymbol', value = 'expr', geneSymbolsNow)

ggplot(df) +
  facet_grid(factor(geneSymbol) ~ factor(cond), scales='free_y') +
  geom_point(aes(x = time, y = expr, shape = cond, color = geneSymbol), size = 1.5) +
  labs(x = 'Zeitgeber time (h)', y = 'Expression (norm.)') +
  scale_shape(solid = FALSE, guide = FALSE) +
  scale_color_brewer(type = 'qual', palette = 'Dark2', guide = FALSE) +
  scale_x_continuous(limits = c(0, 24), breaks = seq(0, 24, 6))
```
